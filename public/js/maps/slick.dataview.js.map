{"version":3,"sources":["slick.dataview.js"],"names":["$","DataView","options","beginUpdate","suspend","endUpdate","refresh","setRefreshHints","hints","refreshHints","setFilterArgs","args","filterArgs","updateIdxById","startingIndex","id","i","l","items","length","idProperty","undefined","idxById","ensureIdUniqueness","getItems","setItems","data","objectIdProperty","filteredItems","setPagingOptions","pageSize","pagesize","pagenum","Math","min","max","ceil","totalRows","pageNum","onPagingInfoChanged","notify","getPagingInfo","self","totalPages","sort","comparer","ascending","sortAsc","sortComparer","fastSortField","reverse","fastSort","field","oldToString","Object","prototype","toString","this","reSort","setFilter","filterFn","filter","inlineFilters","compiledFilter","compileFilter","compiledFilterWithCaching","compileFilterWithCaching","getGrouping","groupingInfos","setGrouping","groupingInfo","groupItemMetadataProvider","Slick","Data","GroupItemMetadataProvider","groups","toggledGroupsByLevel","Array","gi","extend","groupingInfoDefaults","getterIsAFn","getter","compiledAccumulators","idx","aggregators","compileAccumulatorLoop","groupBy","valueGetter","valueFormatter","formatter","setAggregators","groupAggregators","includeCollapsed","Error","aggregateCollapsed","getItemByIdx","getIdxById","ensureRowsByIdCache","rowsById","rows","getRowById","getItemById","mapIdsToRows","idArray","row","mapRowsToIds","rowArray","ids","updateItem","item","updated","insertItem","insertBefore","splice","addItem","push","deleteItem","getLength","getItem","__group","totals","initialized","level","displayTotalsRow","calculateTotals","title","value","__groupTotals","getItemMetadata","getGroupRowMetadata","getTotalsRowMetadata","expandCollapseAllGroups","collapse","collapsed","collapseAllGroups","expandAllGroups","expandCollapseGroup","groupingKey","collapseGroup","slice","call","arguments","arg0","indexOf","groupingDelimiter","split","join","expandGroup","getGroups","extractGroups","parentGroup","group","val","r","groupsByVal","predefinedValues","Group","count","agg","isLeafLevel","aggregateChildGroups","init","storeResult","addGroupTotals","GroupTotals","lazyTotalsCalculation","addTotals","g","groupCollapsed","toggledGroups","aggregateEmpty","flattenGroupedRows","groupedRows","gl","j","jj","getFunctionInfo","fn","fnRegex","matches","match","params","body","aggregator","accumulatorInfo","accumulate","Function","displayName","name","filterInfo","filterBody","replace","tpl","uncompiledFilter","retval","ii","uncompiledFilterWithCaching","cache","getFilteredAndPagedItems","batchFilter","batchFilterWithCaching","isFilterNarrowing","isFilterExpanding","filterCache","isFilterUnchanged","concat","paged","floor","getRowDiffs","newRows","eitherIsNonData","diff","from","to","ignoreDiffsBefore","ignoreDiffsAfter","rl","equals","recalc","_items","prevRefreshHints","countBefore","totalRowsBefore","onRowCountChanged","previous","current","onRowsChanged","syncGridSelection","grid","preserveHidden","preserveHiddenOnSelectionChange","setSelectedRowIds","rowIds","selectedRowIds","onSelectedRowIdsChanged","EventData","update","inHandler","selectedRows","setSelectedRows","getSelectedRows","Event","onSelectedRowsChanged","subscribe","newSelectedRowIds","getOptions","multiSelect","existing","grep","syncGridCellCssStyles","key","storeCellCssStyles","hash","hashById","newHash","setCellCssStyles","getCellCssStyles","onCellCssStylesChanged","e","defaults","a","b","AvgAggregator","field_","count_","nonNullCount_","sum_","NaN","parseFloat","groupTotals","avg","MinAggregator","min_","MaxAggregator","max_","SumAggregator","sum","window","Aggregators","Avg","Min","Max","Sum","jQuery"],"mappings":"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","file":"slick.dataview.js","sourcesContent":["(function ($) {\n  $.extend(true, window, {\n    Slick: {\n      Data: {\n        DataView: DataView,\n        Aggregators: {\n          Avg: AvgAggregator,\n          Min: MinAggregator,\n          Max: MaxAggregator,\n          Sum: SumAggregator\n        }\n      }\n    }\n  });\n\n\n  /***\n   * A sample Model implementation.\n   * Provides a filtered view of the underlying data.\n   *\n   * Relies on the data item having an \"id\" property uniquely identifying it.\n   */\n  function DataView(options) {\n    var self = this;\n\n    var defaults = {\n      groupItemMetadataProvider: null,\n      inlineFilters: false\n    };\n\n\n    // private\n    var idProperty = \"id\";  // property holding a unique row id\n    var items = [];         // data by index\n    var rows = [];          // data by row\n    var idxById = {};       // indexes by id\n    var rowsById = null;    // rows by id; lazy-calculated\n    var filter = null;      // filter function\n    var updated = null;     // updated item ids\n    var suspend = false;    // suspends the recalculation\n    var sortAsc = true;\n    var fastSortField;\n    var sortComparer;\n    var refreshHints = {};\n    var prevRefreshHints = {};\n    var filterArgs;\n    var filteredItems = [];\n    var compiledFilter;\n    var compiledFilterWithCaching;\n    var filterCache = [];\n\n    // grouping\n    var groupingInfoDefaults = {\n      getter: null,\n      formatter: null,\n      comparer: function(a, b) { return a.value - b.value; },\n      predefinedValues: [],\n      aggregators: [],\n      aggregateEmpty: false,\n      aggregateCollapsed: false,\n      aggregateChildGroups: false,\n      collapsed: false,\n      displayTotalsRow: true,\n      lazyTotalsCalculation: false\n    };\n    var groupingInfos = [];\n    var groups = [];\n    var toggledGroupsByLevel = [];\n    var groupingDelimiter = ':|:';\n\n    var pagesize = 0;\n    var pagenum = 0;\n    var totalRows = 0;\n\n    // events\n    var onRowCountChanged = new Slick.Event();\n    var onRowsChanged = new Slick.Event();\n    var onPagingInfoChanged = new Slick.Event();\n\n    options = $.extend(true, {}, defaults, options);\n\n\n    function beginUpdate() {\n      suspend = true;\n    }\n\n    function endUpdate() {\n      suspend = false;\n      refresh();\n    }\n\n    function setRefreshHints(hints) {\n      refreshHints = hints;\n    }\n\n    function setFilterArgs(args) {\n      filterArgs = args;\n    }\n\n    function updateIdxById(startingIndex) {\n      startingIndex = startingIndex || 0;\n      var id;\n      for (var i = startingIndex, l = items.length; i < l; i++) {\n        id = items[i][idProperty];\n        if (id === undefined) {\n          throw \"Each data element must implement a unique 'id' property\";\n        }\n        idxById[id] = i;\n      }\n    }\n\n    function ensureIdUniqueness() {\n      var id;\n      for (var i = 0, l = items.length; i < l; i++) {\n        id = items[i][idProperty];\n        if (id === undefined || idxById[id] !== i) {\n          throw \"Each data element must implement a unique 'id' property\";\n        }\n      }\n    }\n\n    function getItems() {\n      return items;\n    }\n\n    function setItems(data, objectIdProperty) {\n      if (objectIdProperty !== undefined) {\n        idProperty = objectIdProperty;\n      }\n      items = filteredItems = data;\n      idxById = {};\n      updateIdxById();\n      ensureIdUniqueness();\n      refresh();\n    }\n\n    function setPagingOptions(args) {\n      if (args.pageSize != undefined) {\n        pagesize = args.pageSize;\n        pagenum = pagesize ? Math.min(pagenum, Math.max(0, Math.ceil(totalRows / pagesize) - 1)) : 0;\n      }\n\n      if (args.pageNum != undefined) {\n        pagenum = Math.min(args.pageNum, Math.max(0, Math.ceil(totalRows / pagesize) - 1));\n      }\n\n      onPagingInfoChanged.notify(getPagingInfo(), null, self);\n\n      refresh();\n    }\n\n    function getPagingInfo() {\n      var totalPages = pagesize ? Math.max(1, Math.ceil(totalRows / pagesize)) : 1;\n      return {pageSize: pagesize, pageNum: pagenum, totalRows: totalRows, totalPages: totalPages};\n    }\n\n    function sort(comparer, ascending) {\n      sortAsc = ascending;\n      sortComparer = comparer;\n      fastSortField = null;\n      if (ascending === false) {\n        items.reverse();\n      }\n      items.sort(comparer);\n      if (ascending === false) {\n        items.reverse();\n      }\n      idxById = {};\n      updateIdxById();\n      refresh();\n    }\n\n    /***\n     * Provides a workaround for the extremely slow sorting in IE.\n     * Does a [lexicographic] sort on a give column by temporarily overriding Object.prototype.toString\n     * to return the value of that field and then doing a native Array.sort().\n     */\n    function fastSort(field, ascending) {\n      sortAsc = ascending;\n      fastSortField = field;\n      sortComparer = null;\n      var oldToString = Object.prototype.toString;\n      Object.prototype.toString = (typeof field == \"function\") ? field : function () {\n        return this[field]\n      };\n      // an extra reversal for descending sort keeps the sort stable\n      // (assuming a stable native sort implementation, which isn't true in some cases)\n      if (ascending === false) {\n        items.reverse();\n      }\n      items.sort();\n      Object.prototype.toString = oldToString;\n      if (ascending === false) {\n        items.reverse();\n      }\n      idxById = {};\n      updateIdxById();\n      refresh();\n    }\n\n    function reSort() {\n      if (sortComparer) {\n        sort(sortComparer, sortAsc);\n      } else if (fastSortField) {\n        fastSort(fastSortField, sortAsc);\n      }\n    }\n\n    function setFilter(filterFn) {\n      filter = filterFn;\n      if (options.inlineFilters) {\n        compiledFilter = compileFilter();\n        compiledFilterWithCaching = compileFilterWithCaching();\n      }\n      refresh();\n    }\n\n    function getGrouping() {\n      return groupingInfos;\n    }\n\n    function setGrouping(groupingInfo) {\n      if (!options.groupItemMetadataProvider) {\n        options.groupItemMetadataProvider = new Slick.Data.GroupItemMetadataProvider();\n      }\n\n      groups = [];\n      toggledGroupsByLevel = [];\n      groupingInfo = groupingInfo || [];\n      groupingInfos = (groupingInfo instanceof Array) ? groupingInfo : [groupingInfo];\n\n      for (var i = 0; i < groupingInfos.length; i++) {\n        var gi = groupingInfos[i] = $.extend(true, {}, groupingInfoDefaults, groupingInfos[i]);\n        gi.getterIsAFn = typeof gi.getter === \"function\";\n\n        // pre-compile accumulator loops\n        gi.compiledAccumulators = [];\n        var idx = gi.aggregators.length;\n        while (idx--) {\n          gi.compiledAccumulators[idx] = compileAccumulatorLoop(gi.aggregators[idx]);\n        }\n\n        toggledGroupsByLevel[i] = {};\n      }\n\n      refresh();\n    }\n\n    /**\n     * @deprecated Please use {@link setGrouping}.\n     */\n    function groupBy(valueGetter, valueFormatter, sortComparer) {\n      if (valueGetter == null) {\n        setGrouping([]);\n        return;\n      }\n\n      setGrouping({\n        getter: valueGetter,\n        formatter: valueFormatter,\n        comparer: sortComparer\n      });\n    }\n\n    /**\n     * @deprecated Please use {@link setGrouping}.\n     */\n    function setAggregators(groupAggregators, includeCollapsed) {\n      if (!groupingInfos.length) {\n        throw new Error(\"At least one grouping must be specified before calling setAggregators().\");\n      }\n\n      groupingInfos[0].aggregators = groupAggregators;\n      groupingInfos[0].aggregateCollapsed = includeCollapsed;\n\n      setGrouping(groupingInfos);\n    }\n\n    function getItemByIdx(i) {\n      return items[i];\n    }\n\n    function getIdxById(id) {\n      return idxById[id];\n    }\n\n    function ensureRowsByIdCache() {\n      if (!rowsById) {\n        rowsById = {};\n        for (var i = 0, l = rows.length; i < l; i++) {\n          rowsById[rows[i][idProperty]] = i;\n        }\n      }\n    }\n\n    function getRowById(id) {\n      ensureRowsByIdCache();\n      return rowsById[id];\n    }\n\n    function getItemById(id) {\n      return items[idxById[id]];\n    }\n\n    function mapIdsToRows(idArray) {\n      var rows = [];\n      ensureRowsByIdCache();\n      for (var i = 0, l = idArray.length; i < l; i++) {\n        var row = rowsById[idArray[i]];\n        if (row != null) {\n          rows[rows.length] = row;\n        }\n      }\n      return rows;\n    }\n\n    function mapRowsToIds(rowArray) {\n      var ids = [];\n      for (var i = 0, l = rowArray.length; i < l; i++) {\n        if (rowArray[i] < rows.length) {\n          ids[ids.length] = rows[rowArray[i]][idProperty];\n        }\n      }\n      return ids;\n    }\n\n    function updateItem(id, item) {\n      if (idxById[id] === undefined || id !== item[idProperty]) {\n        throw \"Invalid or non-matching id\";\n      }\n      items[idxById[id]] = item;\n      if (!updated) {\n        updated = {};\n      }\n      updated[id] = true;\n      refresh();\n    }\n\n    function insertItem(insertBefore, item) {\n      items.splice(insertBefore, 0, item);\n      updateIdxById(insertBefore);\n      refresh();\n    }\n\n    function addItem(item) {\n      items.push(item);\n      updateIdxById(items.length - 1);\n      refresh();\n    }\n\n    function deleteItem(id) {\n      var idx = idxById[id];\n      if (idx === undefined) {\n        throw \"Invalid id\";\n      }\n      delete idxById[id];\n      items.splice(idx, 1);\n      updateIdxById(idx);\n      refresh();\n    }\n\n    function getLength() {\n      return rows.length;\n    }\n\n    function getItem(i) {\n      var item = rows[i];\n\n      // if this is a group row, make sure totals are calculated and update the title\n      if (item && item.__group && item.totals && !item.totals.initialized) {\n        var gi = groupingInfos[item.level];\n        if (!gi.displayTotalsRow) {\n          calculateTotals(item.totals);\n          item.title = gi.formatter ? gi.formatter(item) : item.value;\n        }\n      }\n      // if this is a totals row, make sure it's calculated\n      else if (item && item.__groupTotals && !item.initialized) {\n        calculateTotals(item);\n      }\n\n      return item;\n    }\n\n    function getItemMetadata(i) {\n      var item = rows[i];\n      if (item === undefined) {\n        return null;\n      }\n\n      // overrides for grouping rows\n      if (item.__group) {\n        return options.groupItemMetadataProvider.getGroupRowMetadata(item);\n      }\n\n      // overrides for totals rows\n      if (item.__groupTotals) {\n        return options.groupItemMetadataProvider.getTotalsRowMetadata(item);\n      }\n\n      return null;\n    }\n\n    function expandCollapseAllGroups(level, collapse) {\n      if (level == null) {\n        for (var i = 0; i < groupingInfos.length; i++) {\n          toggledGroupsByLevel[i] = {};\n          groupingInfos[i].collapsed = collapse;\n        }\n      } else {\n        toggledGroupsByLevel[level] = {};\n        groupingInfos[level].collapsed = collapse;\n      }\n      refresh();\n    }\n\n    /**\n     * @param level {Number} Optional level to collapse.  If not specified, applies to all levels.\n     */\n    function collapseAllGroups(level) {\n      expandCollapseAllGroups(level, true);\n    }\n\n    /**\n     * @param level {Number} Optional level to expand.  If not specified, applies to all levels.\n     */\n    function expandAllGroups(level) {\n      expandCollapseAllGroups(level, false);\n    }\n\n    function expandCollapseGroup(level, groupingKey, collapse) {\n      toggledGroupsByLevel[level][groupingKey] = groupingInfos[level].collapsed ^ collapse;\n      refresh();\n    }\n\n    /**\n     * @param varArgs Either a Slick.Group's \"groupingKey\" property, or a\n     *     variable argument list of grouping values denoting a unique path to the row.  For\n     *     example, calling collapseGroup('high', '10%') will collapse the '10%' subgroup of\n     *     the 'high' group.\n     */\n    function collapseGroup(varArgs) {\n      var args = Array.prototype.slice.call(arguments);\n      var arg0 = args[0];\n      if (args.length == 1 && arg0.indexOf(groupingDelimiter) != -1) {\n        expandCollapseGroup(arg0.split(groupingDelimiter).length - 1, arg0, true);\n      } else {\n        expandCollapseGroup(args.length - 1, args.join(groupingDelimiter), true);\n      }\n    }\n\n    /**\n     * @param varArgs Either a Slick.Group's \"groupingKey\" property, or a\n     *     variable argument list of grouping values denoting a unique path to the row.  For\n     *     example, calling expandGroup('high', '10%') will expand the '10%' subgroup of\n     *     the 'high' group.\n     */\n    function expandGroup(varArgs) {\n      var args = Array.prototype.slice.call(arguments);\n      var arg0 = args[0];\n      if (args.length == 1 && arg0.indexOf(groupingDelimiter) != -1) {\n        expandCollapseGroup(arg0.split(groupingDelimiter).length - 1, arg0, false);\n      } else {\n        expandCollapseGroup(args.length - 1, args.join(groupingDelimiter), false);\n      }\n    }\n\n    function getGroups() {\n      return groups;\n    }\n\n    function extractGroups(rows, parentGroup) {\n      var group;\n      var val;\n      var groups = [];\n      var groupsByVal = {};\n      var r;\n      var level = parentGroup ? parentGroup.level + 1 : 0;\n      var gi = groupingInfos[level];\n\n      for (var i = 0, l = gi.predefinedValues.length; i < l; i++) {\n        val = gi.predefinedValues[i];\n        group = groupsByVal[val];\n        if (!group) {\n          group = new Slick.Group();\n          group.value = val;\n          group.level = level;\n          group.groupingKey = (parentGroup ? parentGroup.groupingKey + groupingDelimiter : '') + val;\n          groups[groups.length] = group;\n          groupsByVal[val] = group;\n        }\n      }\n\n      for (var i = 0, l = rows.length; i < l; i++) {\n        r = rows[i];\n        val = gi.getterIsAFn ? gi.getter(r) : r[gi.getter];\n        group = groupsByVal[val];\n        if (!group) {\n          group = new Slick.Group();\n          group.value = val;\n          group.level = level;\n          group.groupingKey = (parentGroup ? parentGroup.groupingKey + groupingDelimiter : '') + val;\n          groups[groups.length] = group;\n          groupsByVal[val] = group;\n        }\n\n        group.rows[group.count++] = r;\n      }\n\n      if (level < groupingInfos.length - 1) {\n        for (var i = 0; i < groups.length; i++) {\n          group = groups[i];\n          group.groups = extractGroups(group.rows, group);\n        }\n      }      \n\n      groups.sort(groupingInfos[level].comparer);\n\n      return groups;\n    }\n\n    function calculateTotals(totals) {\n      var group = totals.group;\n      var gi = groupingInfos[group.level];\n      var isLeafLevel = (group.level == groupingInfos.length);\n      var agg, idx = gi.aggregators.length;\n\n      if (!isLeafLevel && gi.aggregateChildGroups) {\n        // make sure all the subgroups are calculated\n        var i = group.groups.length;\n        while (i--) {\n          if (!group.groups[i].initialized) {\n            calculateTotals(group.groups[i]);\n          }\n        }\n      }\n\n      while (idx--) {\n        agg = gi.aggregators[idx];\n        agg.init();\n        if (!isLeafLevel && gi.aggregateChildGroups) {\n          gi.compiledAccumulators[idx].call(agg, group.groups);\n        } else {\n          gi.compiledAccumulators[idx].call(agg, group.rows);\n        }\n        agg.storeResult(totals);\n      }\n      totals.initialized = true;\n    }\n\n    function addGroupTotals(group) {\n      var gi = groupingInfos[group.level];\n      var totals = new Slick.GroupTotals();\n      totals.group = group;\n      group.totals = totals;\n      if (!gi.lazyTotalsCalculation) {\n        calculateTotals(totals);\n      }\n    }\n\n    function addTotals(groups, level) {\n      level = level || 0;\n      var gi = groupingInfos[level];\n      var groupCollapsed = gi.collapsed;\n      var toggledGroups = toggledGroupsByLevel[level];      \n      var idx = groups.length, g;\n      while (idx--) {\n        g = groups[idx];\n\n        if (g.collapsed && !gi.aggregateCollapsed) {\n          continue;\n        }\n\n        // Do a depth-first aggregation so that parent group aggregators can access subgroup totals.\n        if (g.groups) {\n          addTotals(g.groups, level + 1);\n        }\n\n        if (gi.aggregators.length && (\n            gi.aggregateEmpty || g.rows.length || (g.groups && g.groups.length))) {\n          addGroupTotals(g);\n        }\n\n        g.collapsed = groupCollapsed ^ toggledGroups[g.groupingKey];\n        g.title = gi.formatter ? gi.formatter(g) : g.value;\n      }\n    } \n\n    function flattenGroupedRows(groups, level) {\n      level = level || 0;\n      var gi = groupingInfos[level];\n      var groupedRows = [], rows, gl = 0, g;\n      for (var i = 0, l = groups.length; i < l; i++) {\n        g = groups[i];\n        groupedRows[gl++] = g;\n\n        if (!g.collapsed) {\n          rows = g.groups ? flattenGroupedRows(g.groups, level + 1) : g.rows;\n          for (var j = 0, jj = rows.length; j < jj; j++) {\n            groupedRows[gl++] = rows[j];\n          }\n        }\n\n        if (g.totals && gi.displayTotalsRow && (!g.collapsed || gi.aggregateCollapsed)) {\n          groupedRows[gl++] = g.totals;\n        }\n      }\n      return groupedRows;\n    }\n\n    function getFunctionInfo(fn) {\n      var fnRegex = /^function[^(]*\\(([^)]*)\\)\\s*{([\\s\\S]*)}$/;\n      var matches = fn.toString().match(fnRegex);\n      return {\n        params: matches[1].split(\",\"),\n        body: matches[2]\n      };\n    }\n\n    function compileAccumulatorLoop(aggregator) {\n      var accumulatorInfo = getFunctionInfo(aggregator.accumulate);\n      var fn = new Function(\n          \"_items\",\n          \"for (var \" + accumulatorInfo.params[0] + \", _i=0, _il=_items.length; _i<_il; _i++) {\" +\n              accumulatorInfo.params[0] + \" = _items[_i]; \" +\n              accumulatorInfo.body +\n          \"}\"\n      );\n      fn.displayName = fn.name = \"compiledAccumulatorLoop\";\n      return fn;\n    }\n\n    function compileFilter() {\n      var filterInfo = getFunctionInfo(filter);\n\n      var filterBody = filterInfo.body\n          .replace(/return false\\s*([;}]|$)/gi, \"{ continue _coreloop; }$1\")\n          .replace(/return true\\s*([;}]|$)/gi, \"{ _retval[_idx++] = $item$; continue _coreloop; }$1\")\n          .replace(/return ([^;}]+?)\\s*([;}]|$)/gi,\n          \"{ if ($1) { _retval[_idx++] = $item$; }; continue _coreloop; }$2\");\n\n      // This preserves the function template code after JS compression,\n      // so that replace() commands still work as expected.\n      var tpl = [\n        //\"function(_items, _args) { \",\n        \"var _retval = [], _idx = 0; \",\n        \"var $item$, $args$ = _args; \",\n        \"_coreloop: \",\n        \"for (var _i = 0, _il = _items.length; _i < _il; _i++) { \",\n        \"$item$ = _items[_i]; \",\n        \"$filter$; \",\n        \"} \",\n        \"return _retval; \"\n        //\"}\"\n      ].join(\"\");\n      tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n      tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n      tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n\n      var fn = new Function(\"_items,_args\", tpl);\n      fn.displayName = fn.name = \"compiledFilter\";\n      return fn;\n    }\n\n    function compileFilterWithCaching() {\n      var filterInfo = getFunctionInfo(filter);\n\n      var filterBody = filterInfo.body\n          .replace(/return false\\s*([;}]|$)/gi, \"{ continue _coreloop; }$1\")\n          .replace(/return true\\s*([;}]|$)/gi, \"{ _cache[_i] = true;_retval[_idx++] = $item$; continue _coreloop; }$1\")\n          .replace(/return ([^;}]+?)\\s*([;}]|$)/gi,\n          \"{ if ((_cache[_i] = $1)) { _retval[_idx++] = $item$; }; continue _coreloop; }$2\");\n\n      // This preserves the function template code after JS compression,\n      // so that replace() commands still work as expected.\n      var tpl = [\n        //\"function(_items, _args, _cache) { \",\n        \"var _retval = [], _idx = 0; \",\n        \"var $item$, $args$ = _args; \",\n        \"_coreloop: \",\n        \"for (var _i = 0, _il = _items.length; _i < _il; _i++) { \",\n        \"$item$ = _items[_i]; \",\n        \"if (_cache[_i]) { \",\n        \"_retval[_idx++] = $item$; \",\n        \"continue _coreloop; \",\n        \"} \",\n        \"$filter$; \",\n        \"} \",\n        \"return _retval; \"\n        //\"}\"\n      ].join(\"\");\n      tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n      tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n      tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n\n      var fn = new Function(\"_items,_args,_cache\", tpl);\n      fn.displayName = fn.name = \"compiledFilterWithCaching\";\n      return fn;\n    }\n\n    function uncompiledFilter(items, args) {\n      var retval = [], idx = 0;\n\n      for (var i = 0, ii = items.length; i < ii; i++) {\n        if (filter(items[i], args)) {\n          retval[idx++] = items[i];\n        }\n      }\n\n      return retval;\n    }\n\n    function uncompiledFilterWithCaching(items, args, cache) {\n      var retval = [], idx = 0, item;\n\n      for (var i = 0, ii = items.length; i < ii; i++) {\n        item = items[i];\n        if (cache[i]) {\n          retval[idx++] = item;\n        } else if (filter(item, args)) {\n          retval[idx++] = item;\n          cache[i] = true;\n        }\n      }\n\n      return retval;\n    }\n\n    function getFilteredAndPagedItems(items) {\n      if (filter) {\n        var batchFilter = options.inlineFilters ? compiledFilter : uncompiledFilter;\n        var batchFilterWithCaching = options.inlineFilters ? compiledFilterWithCaching : uncompiledFilterWithCaching;\n\n        if (refreshHints.isFilterNarrowing) {\n          filteredItems = batchFilter(filteredItems, filterArgs);\n        } else if (refreshHints.isFilterExpanding) {\n          filteredItems = batchFilterWithCaching(items, filterArgs, filterCache);\n        } else if (!refreshHints.isFilterUnchanged) {\n          filteredItems = batchFilter(items, filterArgs);\n        }\n      } else {\n        // special case:  if not filtering and not paging, the resulting\n        // rows collection needs to be a copy so that changes due to sort\n        // can be caught\n        filteredItems = pagesize ? items : items.concat();\n      }\n\n      // get the current page\n      var paged;\n      if (pagesize) {\n        if (filteredItems.length < pagenum * pagesize) {\n          pagenum = Math.floor(filteredItems.length / pagesize);\n        }\n        paged = filteredItems.slice(pagesize * pagenum, pagesize * pagenum + pagesize);\n      } else {\n        paged = filteredItems;\n      }\n\n      return {totalRows: filteredItems.length, rows: paged};\n    }\n\n    function getRowDiffs(rows, newRows) {\n      var item, r, eitherIsNonData, diff = [];\n      var from = 0, to = newRows.length;\n\n      if (refreshHints && refreshHints.ignoreDiffsBefore) {\n        from = Math.max(0,\n            Math.min(newRows.length, refreshHints.ignoreDiffsBefore));\n      }\n\n      if (refreshHints && refreshHints.ignoreDiffsAfter) {\n        to = Math.min(newRows.length,\n            Math.max(0, refreshHints.ignoreDiffsAfter));\n      }\n\n      for (var i = from, rl = rows.length; i < to; i++) {\n        if (i >= rl) {\n          diff[diff.length] = i;\n        } else {\n          item = newRows[i];\n          r = rows[i];\n\n          if ((groupingInfos.length && (eitherIsNonData = (item.__nonDataRow) || (r.__nonDataRow)) &&\n              item.__group !== r.__group ||\n              item.__group && !item.equals(r))\n              || (eitherIsNonData &&\n              // no good way to compare totals since they are arbitrary DTOs\n              // deep object comparison is pretty expensive\n              // always considering them 'dirty' seems easier for the time being\n              (item.__groupTotals || r.__groupTotals))\n              || item[idProperty] != r[idProperty]\n              || (updated && updated[item[idProperty]])\n              ) {\n            diff[diff.length] = i;\n          }\n        }\n      }\n      return diff;\n    }\n\n    function recalc(_items) {\n      rowsById = null;\n\n      if (refreshHints.isFilterNarrowing != prevRefreshHints.isFilterNarrowing ||\n          refreshHints.isFilterExpanding != prevRefreshHints.isFilterExpanding) {\n        filterCache = [];\n      }\n\n      var filteredItems = getFilteredAndPagedItems(_items);\n      totalRows = filteredItems.totalRows;\n      var newRows = filteredItems.rows;\n\n      groups = [];\n      if (groupingInfos.length) {\n        groups = extractGroups(newRows);\n        if (groups.length) {\n          addTotals(groups);\n          newRows = flattenGroupedRows(groups);\n        }\n      }\n\n      var diff = getRowDiffs(rows, newRows);\n\n      rows = newRows;\n\n      return diff;\n    }\n\n    function refresh() {\n      if (suspend) {\n        return;\n      }\n\n      var countBefore = rows.length;\n      var totalRowsBefore = totalRows;\n\n      var diff = recalc(items, filter); // pass as direct refs to avoid closure perf hit\n\n      // if the current page is no longer valid, go to last page and recalc\n      // we suffer a performance penalty here, but the main loop (recalc) remains highly optimized\n      if (pagesize && totalRows < pagenum * pagesize) {\n        pagenum = Math.max(0, Math.ceil(totalRows / pagesize) - 1);\n        diff = recalc(items, filter);\n      }\n\n      updated = null;\n      prevRefreshHints = refreshHints;\n      refreshHints = {};\n\n      if (totalRowsBefore != totalRows) {\n        onPagingInfoChanged.notify(getPagingInfo(), null, self);\n      }\n      if (countBefore != rows.length) {\n        onRowCountChanged.notify({previous: countBefore, current: rows.length}, null, self);\n      }\n      if (diff.length > 0) {\n        onRowsChanged.notify({rows: diff}, null, self);\n      }\n    }\n\n    /***\n     * Wires the grid and the DataView together to keep row selection tied to item ids.\n     * This is useful since, without it, the grid only knows about rows, so if the items\n     * move around, the same rows stay selected instead of the selection moving along\n     * with the items.\n     *\n     * NOTE:  This doesn't work with cell selection model.\n     *\n     * @param grid {Slick.Grid} The grid to sync selection with.\n     * @param preserveHidden {Boolean} Whether to keep selected items that go out of the\n     *     view due to them getting filtered out.\n     * @param preserveHiddenOnSelectionChange {Boolean} Whether to keep selected items\n     *     that are currently out of the view (see preserveHidden) as selected when selection\n     *     changes.\n     * @return {Slick.Event} An event that notifies when an internal list of selected row ids\n     *     changes.  This is useful since, in combination with the above two options, it allows\n     *     access to the full list selected row ids, and not just the ones visible to the grid.\n     * @method syncGridSelection\n     */\n    function syncGridSelection(grid, preserveHidden, preserveHiddenOnSelectionChange) {\n      var self = this;\n      var inHandler;\n      var selectedRowIds = self.mapRowsToIds(grid.getSelectedRows());\n      var onSelectedRowIdsChanged = new Slick.Event();\n\n      function setSelectedRowIds(rowIds) {\n        if (selectedRowIds.join(\",\") == rowIds.join(\",\")) {\n          return;\n        }\n\n        selectedRowIds = rowIds;\n\n        onSelectedRowIdsChanged.notify({\n          \"grid\": grid,\n          \"ids\": selectedRowIds\n        }, new Slick.EventData(), self);\n      }\n\n      function update() {\n        if (selectedRowIds.length > 0) {\n          inHandler = true;\n          var selectedRows = self.mapIdsToRows(selectedRowIds);\n          if (!preserveHidden) {\n            setSelectedRowIds(self.mapRowsToIds(selectedRows));       \n          }\n          grid.setSelectedRows(selectedRows);\n          inHandler = false;\n        }\n      }\n\n      grid.onSelectedRowsChanged.subscribe(function(e, args) {\n        if (inHandler) { return; }\n        var newSelectedRowIds = self.mapRowsToIds(grid.getSelectedRows());\n        if (!preserveHiddenOnSelectionChange || !grid.getOptions().multiSelect) {\n          setSelectedRowIds(newSelectedRowIds);\n        } else {\n          // keep the ones that are hidden\n          var existing = $.grep(selectedRowIds, function(id) { return self.getRowById(id) === undefined; });\n          // add the newly selected ones\n          setSelectedRowIds(existing.concat(newSelectedRowIds));\n        }\n      });\n\n      this.onRowsChanged.subscribe(update);\n\n      this.onRowCountChanged.subscribe(update);\n\n      return onSelectedRowIdsChanged;\n    }\n\n    function syncGridCellCssStyles(grid, key) {\n      var hashById;\n      var inHandler;\n\n      // since this method can be called after the cell styles have been set,\n      // get the existing ones right away\n      storeCellCssStyles(grid.getCellCssStyles(key));\n\n      function storeCellCssStyles(hash) {\n        hashById = {};\n        for (var row in hash) {\n          var id = rows[row][idProperty];\n          hashById[id] = hash[row];\n        }\n      }\n\n      function update() {\n        if (hashById) {\n          inHandler = true;\n          ensureRowsByIdCache();\n          var newHash = {};\n          for (var id in hashById) {\n            var row = rowsById[id];\n            if (row != undefined) {\n              newHash[row] = hashById[id];\n            }\n          }\n          grid.setCellCssStyles(key, newHash);\n          inHandler = false;\n        }\n      }\n\n      grid.onCellCssStylesChanged.subscribe(function(e, args) {\n        if (inHandler) { return; }\n        if (key != args.key) { return; }\n        if (args.hash) {\n          storeCellCssStyles(args.hash);\n        }\n      });\n\n      this.onRowsChanged.subscribe(update);\n\n      this.onRowCountChanged.subscribe(update);\n    }\n\n    $.extend(this, {\n      // methods\n      \"beginUpdate\": beginUpdate,\n      \"endUpdate\": endUpdate,\n      \"setPagingOptions\": setPagingOptions,\n      \"getPagingInfo\": getPagingInfo,\n      \"getItems\": getItems,\n      \"setItems\": setItems,\n      \"setFilter\": setFilter,\n      \"sort\": sort,\n      \"fastSort\": fastSort,\n      \"reSort\": reSort,\n      \"setGrouping\": setGrouping,\n      \"getGrouping\": getGrouping,\n      \"groupBy\": groupBy,\n      \"setAggregators\": setAggregators,\n      \"collapseAllGroups\": collapseAllGroups,\n      \"expandAllGroups\": expandAllGroups,\n      \"collapseGroup\": collapseGroup,\n      \"expandGroup\": expandGroup,\n      \"getGroups\": getGroups,\n      \"getIdxById\": getIdxById,\n      \"getRowById\": getRowById,\n      \"getItemById\": getItemById,\n      \"getItemByIdx\": getItemByIdx,\n      \"mapRowsToIds\": mapRowsToIds,\n      \"mapIdsToRows\": mapIdsToRows,\n      \"setRefreshHints\": setRefreshHints,\n      \"setFilterArgs\": setFilterArgs,\n      \"refresh\": refresh,\n      \"updateItem\": updateItem,\n      \"insertItem\": insertItem,\n      \"addItem\": addItem,\n      \"deleteItem\": deleteItem,\n      \"syncGridSelection\": syncGridSelection,\n      \"syncGridCellCssStyles\": syncGridCellCssStyles,\n\n      // data provider methods\n      \"getLength\": getLength,\n      \"getItem\": getItem,\n      \"getItemMetadata\": getItemMetadata,\n\n      // events\n      \"onRowCountChanged\": onRowCountChanged,\n      \"onRowsChanged\": onRowsChanged,\n      \"onPagingInfoChanged\": onPagingInfoChanged\n    });\n  }\n\n  function AvgAggregator(field) {\n    this.field_ = field;\n\n    this.init = function () {\n      this.count_ = 0;\n      this.nonNullCount_ = 0;\n      this.sum_ = 0;\n    };\n\n    this.accumulate = function (item) {\n      var val = item[this.field_];\n      this.count_++;\n      if (val != null && val !== \"\" && val !== NaN) {\n        this.nonNullCount_++;\n        this.sum_ += parseFloat(val);\n      }\n    };\n\n    this.storeResult = function (groupTotals) {\n      if (!groupTotals.avg) {\n        groupTotals.avg = {};\n      }\n      if (this.nonNullCount_ != 0) {\n        groupTotals.avg[this.field_] = this.sum_ / this.nonNullCount_;\n      }\n    };\n  }\n\n  function MinAggregator(field) {\n    this.field_ = field;\n\n    this.init = function () {\n      this.min_ = null;\n    };\n\n    this.accumulate = function (item) {\n      var val = item[this.field_];\n      if (val != null && val !== \"\" && val !== NaN) {\n        if (this.min_ == null || val < this.min_) {\n          this.min_ = val;\n        }\n      }\n    };\n\n    this.storeResult = function (groupTotals) {\n      if (!groupTotals.min) {\n        groupTotals.min = {};\n      }\n      groupTotals.min[this.field_] = this.min_;\n    }\n  }\n\n  function MaxAggregator(field) {\n    this.field_ = field;\n\n    this.init = function () {\n      this.max_ = null;\n    };\n\n    this.accumulate = function (item) {\n      var val = item[this.field_];\n      if (val != null && val !== \"\" && val !== NaN) {\n        if (this.max_ == null || val > this.max_) {\n          this.max_ = val;\n        }\n      }\n    };\n\n    this.storeResult = function (groupTotals) {\n      if (!groupTotals.max) {\n        groupTotals.max = {};\n      }\n      groupTotals.max[this.field_] = this.max_;\n    }\n  }\n\n  function SumAggregator(field) {\n    this.field_ = field;\n\n    this.init = function () {\n      this.sum_ = null;\n    };\n\n    this.accumulate = function (item) {\n      var val = item[this.field_];\n      if (val != null && val !== \"\" && val !== NaN) {\n        this.sum_ += parseFloat(val);\n      }\n    };\n\n    this.storeResult = function (groupTotals) {\n      if (!groupTotals.sum) {\n        groupTotals.sum = {};\n      }\n      groupTotals.sum[this.field_] = this.sum_;\n    }\n  }\n\n  // TODO:  add more built-in aggregators\n  // TODO:  merge common aggregators in one to prevent needles iterating\n\n})(jQuery);\n"],"sourceRoot":"/source/"}